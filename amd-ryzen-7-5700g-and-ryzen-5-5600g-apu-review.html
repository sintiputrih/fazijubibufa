<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>CPU Tests: Simulation and Rendering -</title><meta name=robots content="index,follow,noarchive"><meta name=description content="CPU Tests: Simulation Simulation and Science have a lot of overlap in the benchmarking world, however for this distinction we’re separating into two segments mostly based on the utility of the resulting data. The benchmarks that fall under Science have a distinct use for the data they output – in our Simulation section, these act more like synthetics but at some level are still trying to simulate a given environment."><meta name=author content="Reinaldo Massengill"><link rel="preload stylesheet" as=style href=https://assets.cdnweb.info/hugo/paper/css/app.css><link rel="preload stylesheet" as=style href=https://assets.cdnweb.info/hugo/paper/css/an-old-hope.min.css><script defer src=https://assets.cdnweb.info/hugo/paper/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=preload as=image href=./theme.png><link rel=icon href=./favicon.ico><link rel=apple-touch-icon href=./apple-touch-icon.png><meta name=generator content="Hugo 0.98.0"><meta property="og:title" content="CPU Tests: Simulation and Rendering"><meta property="og:description" content="Simulation and Science have a lot of overlap in the benchmarking world, however for this distinction were separating into two segments mostly based on the utility of the resulting data. The benchmarks that fall under Science have a distinct use for the data they output  in our Simulation section, these act more like synthetics"><meta property="og:type" content="article"><meta property="og:url" content="/amd-ryzen-7-5700g-and-ryzen-5-5600g-apu-review.html"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-09-21T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-21T00:00:00+00:00"><meta itemprop=name content="CPU Tests: Simulation and Rendering"><meta itemprop=description content="Simulation and Science have a lot of overlap in the benchmarking world, however for this distinction were separating into two segments mostly based on the utility of the resulting data. The benchmarks that fall under Science have a distinct use for the data they output  in our Simulation section, these act more like synthetics"><meta itemprop=datePublished content="2024-09-21T00:00:00+00:00"><meta itemprop=dateModified content="2024-09-21T00:00:00+00:00"><meta itemprop=wordCount content="2176"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="CPU Tests: Simulation and Rendering"><meta name=twitter:description content="Simulation and Science have a lot of overlap in the benchmarking world, however for this distinction were separating into two segments mostly based on the utility of the resulting data. The benchmarks that fall under Science have a distinct use for the data they output  in our Simulation section, these act more like synthetics"></head><body class=not-ready data-menu=true><header class=header><p class=logo><a class=site-name href=./index.html>BlogPaper</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList,btnDark=document.querySelector(".btn-dark"),sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>{bodyClx[e?"add":"remove"]("dark"),localStorage.setItem("dark",e?"yes":"no")};setDark(darkVal?darkVal==="yes":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",e=>setDark(e.matches))</script><nav class=menu><a href=./sitemap.xml>Sitemap</a></nav></header><main class=main><article class=post-single><header class=post-title><p><time>Sep 21, 2024</time>
<span>Reinaldo Massengill</span></p><h1>CPU Tests: Simulation and Rendering</h1></header><section class=post-content><h2>CPU Tests: Simulation</h2><p>Simulation and Science have a lot of overlap in the benchmarking world, however for this distinction we’re separating into two segments mostly based on the utility of the resulting data. The benchmarks that fall under Science have a distinct use for the data they output – in our Simulation section, these act more like synthetics but at some level are still trying to simulate a given environment.</p><h3>DigiCortex v1.35: <a href=#>link</a></h3><p>DigiCortex is a pet project for the visualization of neuron and synapse activity in the brain. The software comes with a variety of benchmark modes, and we take the small benchmark which runs a 32k neuron/1.8B synapse simulation, similar to a small slug.</p><p>The results on the output are given as a fraction of whether the system can simulate in real-time, so anything above a value of one is suitable for real-time work. The benchmark offers a 'no firing synapse' mode, which in essence detects DRAM and bus speed, however we take the firing mode which adds CPU work with every firing.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/16824/CPU-3-1-DigiCortexLarge_575px.gif style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>The software originally shipped with a benchmark that recorded the first few cycles and output a result. So while fast multi-threaded processors this made the benchmark last less than a few seconds, slow dual-core processors could be running for almost an hour. There is also the issue of DigiCortex starting with a base neuron/synapse map in ‘off mode’, giving a high result in the first few cycles as none of the nodes are currently active. We found that the performance settles down into a steady state after a while (when the model is actively in use), so we asked the author to allow for a ‘warm-up’ phase and for the benchmark to be the average over a second sample time.</p><p>For our test, we give the benchmark 20000 cycles to warm up and then take the data over the next 10000 cycles seconds for the test – on a modern processor this takes 30 seconds and 150 seconds respectively. This is then repeated a minimum of 10 times, with the first three results rejected. Results are shown as a multiple of real-time calculation.</p><p align=center><img alt="(3-1) DigiCortex 1.35 (32k Neuron, 1.8B Synapse)" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph16824/124894.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>The Zen3 processors have been doing well in the Digicortex test due to the rearrangement of load/store ports with better memory access. We're seeing >2x gen-on-gen gains here.</p><h3>Dwarf Fortress 0.44.12: <a href=#>Link</a></h3><p>Another long standing request for our benchmark suite has been Dwarf Fortress, a popular management/roguelike indie video game, first launched in 2006 and still being regularly updated today, <a href=#>aiming for a Steam launch</a> sometime in the future.</p><p>Emulating the ASCII interfaces of old, this title is a rather complex beast, which can generate environments subject to millennia of rule, famous faces, peasants, and key historical figures and events. The further you get into the game, depending on the size of the world, the slower it becomes as it has to simulate more famous people, more world events, and the natural way that humanoid creatures take over an environment. Like some kind of virus.</p><p>For our test we’re using DFMark. DFMark is a benchmark&nbsp;<a href=#>built by vorsgren</a>&nbsp;on the Bay12Forums that gives two different modes built on DFHack: world generation and embark. These tests can be configured, but range anywhere from 3 minutes to several hours. After analyzing the test, we ended up going for three different world generation sizes:</p><ul><li>Small, a 65x65 world with 250 years, 10 civilizations and 4 megabeasts</li><li>Medium, a 127x127 world with 550 years, 10 civilizations and 4 megabeasts</li><li>Large, a 257x257 world with 550 years, 40 civilizations and 10 megabeasts</li></ul><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/16824/CPU-3-2-DF_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>DFMark outputs the time to run any given test, so this is what we use for the output. We loop the small test for as many times possible in 10 minutes, the medium test for as many times in 30 minutes, and the large test for as many times in an hour.</p><p align=center><img alt="(3-2c) Dwarf Fortress 0.44.12 World Gen 257x257, 550 Yr" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph16824/124897.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>In our largest sub-test, the Intel processors crack on ahead, however comparing AMD gen-on-gen and even the R3 5300G comes out ahead of the previous generation's R7.</p><h3>Dolphin v5.0 Emulation: <a href=#>Link</a></h3><p>Many emulators are often bound by single thread CPU performance, and general reports tended to suggest that Haswell provided a significant boost to emulator performance. This benchmark runs a Wii program that ray traces a complex 3D scene inside the Dolphin Wii emulator. Performance on this benchmark is a good proxy of the speed of Dolphin CPU emulation, which is an intensive single core task using most aspects of a CPU. Results are given in seconds, where the Wii itself scores 1051 seconds.</p><p align=center><img alt="(3-3) Dolphin 5.0 Render Test" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph16824/124898.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>Emulation improvement increases are across the board.</p><h2>CPU Tests: Rendering</h2><p>Rendering tests, compared to others, are often a little more simple to digest and automate. All the tests put out some sort of score or time, usually in an obtainable way that makes it fairly easy to extract. These tests are some of the most strenuous in our list, due to the highly threaded nature of rendering and ray-tracing, and can draw a lot of power. If a system is not properly configured to deal with the thermal requirements of the processor, the rendering benchmarks is where it would show most easily as the frequency drops over a sustained period of time. Most benchmarks in this case are re-run several times, and the key to this is having an appropriate idle/wait time between benchmarks to allow for temperatures to normalize from the last test.</p><h3>Blender 2.83 LTS: <a href=#>Link</a></h3><p>One of the popular tools for rendering is Blender, with it being a public open source project that anyone in the animation industry can get involved in. This extends to conferences, use in films and VR, with a dedicated Blender Institute, and everything you might expect from a professional software package (except perhaps a professional grade support package). With it being open-source, studios can customize it in as many ways as they need to get the results they require. It ends up being a big optimization target for both Intel and AMD in this regard.</p><p>For benchmarking purposes, we fell back to one rendering a frame from a detailed project. Most reviews, as we have done in the past, focus on one of the classic Blender renders, known as BMW_27. It can take anywhere from a few minutes to almost an hour on a regular system. However now that Blender has moved onto a Long Term Support model (LTS) with the latest 2.83 release, we decided to go for something different.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/16824/CPU-4-1-Blender_575px.jpg style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>We use this scene, called <a href=#>PartyTug at 6AM by Ian Hubert</a>, which is the official image of Blender 2.83. It is 44.3 MB in size, and uses some of the more modern compute properties of Blender. As it is more complex than the BMW scene, but uses different aspects of the compute model, time to process is roughly similar to before. We loop the scene for at least 10 minutes, taking the average time of the completions taken. Blender offers a command-line tool for batch commands, and we redirect the output into a text file.</p><p align=center><img alt="(4-1) Blender 2.83 Custom Render Test" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph16824/124902.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>Blender performance increases generationally are around 4%.</p><h3>Corona 1.3: <a href=#>Link</a></h3><p>Corona is billed as a popular high-performance photorealistic rendering engine for 3ds Max, with development for Cinema 4D support as well. In order to promote the software, the developers produced a downloadable benchmark on the 1.3 version of the software, with a ray-traced scene involving a military vehicle and a lot of foliage. The software does multiple passes, calculating the scene, geometry, preconditioning and rendering, with performance measured in the time to finish the benchmark (the official metric used on their website) or in rays per second (the metric we use to offer a more linear scale).</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/16824/CPU-4-2-Corona_575px.jpg style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>The standard benchmark provided by Corona is interface driven: the scene is calculated and displayed in front of the user, with the ability to upload the result to their online database. We got in contact with the developers, who provided us with a non-interface version that allowed for command-line entry and retrieval of the results very easily.&nbsp; We loop around the benchmark five times, waiting 60 seconds between each, and taking an overall average. The time to run this benchmark can be around 10 minutes on a Core i9, up to over an hour on a quad-core 2014 AMD processor or dual-core Pentium.</p><p align=center><img alt="(4-2) Corona 1.3 Benchmark" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph16824/124903.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>With Corona, the 5700G is +28% over the previous generation. That jump narrows down to +13% with the R3, but we're seeing good yearly improvements.</p><h3>Crysis CPU-Only Gameplay</h3><p>One of the most oft used memes in computer gaming is ‘Can It Run Crysis?’. The original 2007 game, built in the Crytek engine by Crytek, was heralded as a computationally complex title for the hardware at the time and several years after, suggesting that a user needed graphics hardware from the future in order to run it. Fast forward over a decade, and the game runs fairly easily on modern GPUs.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/16824/CPU-4-3-Crysis_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>But can we also apply the same concept to pure CPU rendering? Can a CPU, on its own, render Crysis? Since 64 core processors entered the market, one can dream. So we built a benchmark to see whether the hardware can.</p><p>For this test, we’re running Crysis’ own GPU benchmark, but in CPU render mode. This is a 2000 frame test, with medium and low settings.</p><p align=center><img alt="(4-3b) Crysis CPU Render at 1080p Low" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph16824/124904.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><h3>POV-Ray 3.7.1: <a href=#>Link</a></h3><p>A long time benchmark staple, POV-Ray is another rendering program that is well known to load up every single thread in a system, regardless of cache and memory levels. After a long period of POV-Ray 3.7 being the latest official release, when AMD launched Ryzen the POV-Ray codebase suddenly saw a range of activity from both AMD and Intel, knowing that the software (with the built-in benchmark) would be an optimization tool for the hardware.</p><p>We had to stick a flag in the sand when it came to selecting the version that was fair to both AMD and Intel, and still relevant to end-users. Version 3.7.1 fixes a significant bug in the early 2017 code that was advised against in both Intel and AMD manuals regarding to write-after-read, leading to a nice performance boost.</p><p>The benchmark can take over 20 minutes on a slow system with few cores, or around a minute or two on a fast system, or seconds with a dual high-core count EPYC. Because POV-Ray draws a large amount of power and current, it is important to make sure the cooling is sufficient here and the system stays in its high-power state. Using a motherboard with a poor power-delivery and low airflow could create an issue that won’t be obvious in some CPU positioning if the power limit only causes a 100 MHz drop as it changes P-states.</p><p align=center><img alt="(4-4) POV-Ray 3.7.1" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph16824/124905.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>We see +3% performance on the R7, whereas R3/R5 is more akin to +10%.</p><h3>V-Ray: <a href=#>Link</a></h3><p>We have a couple of renderers and ray tracers in our suite already, however V-Ray’s benchmark came through for a requested benchmark enough for us to roll it into our suite. Built by ChaosGroup, V-Ray is a 3D rendering package compatible with a number of popular commercial imaging applications, such as 3ds Max, Maya, Undreal, Cinema 4D, and Blender.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/16824/CPU-4-5-V-Ray_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>We run the <a href=#>standard standalone benchmark</a> application, but in an automated fashion to pull out the result in the form of kilosamples/second. We run the test six times and take an average of the valid results.</p><p align=center><img alt="(4-5) V-Ray Renderer" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph16824/124906.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>With a big +26% jump for the R7 (+21% for R5, +11% for R3), some rendering tasks really like the new processors.</p><h3>Cinebench R20: <a href=#>Link</a></h3><p>Another common stable of a benchmark suite is Cinebench. Based on Cinema4D, Cinebench is a purpose built benchmark machine that renders a scene with both single and multi-threaded options. The scene is identical in both cases. The R20 version means that it targets Cinema 4D R20, a slightly older version of the software which is currently on version R21. Cinebench R20 was launched given that the R15 version had been out a long time, and despite the difference between the benchmark and the latest version of the software on which it is based, Cinebench results are often quoted a lot in marketing materials.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/16824/CPU-4-6-CBR20_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>Results for Cinebench R20 are not comparable to R15 or older, because both the scene being used is different, but also the updates in the code bath. The results are output as a score from the software, which is directly proportional to the time taken. Using the benchmark flags for single CPU and multi-CPU workloads, we run the software from the command line which opens the test, runs it, and dumps the result into the console which is redirected to a text file. The test is repeated for a minimum of 10 minutes for both ST and MT, and then the runs averaged.</p><p align=center><img alt="(4-6a) CineBench R20 Single Thread" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph16824/124907.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto><img alt="(4-6b) CineBench R20 Multi-Thread" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph16824/124908.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>As we saw when Zen 3 first launched, the performance improvements in single thread are quite substantial - even the 5300G is faster than the previous generation's best APU. Compare it back to the R5 3400G, the last retail APU, and it's almost a 50% jump in Cinebench 1T performance.</p><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmivp6x7orrAp5utnZOde6S7zGiqoaenZH53hJFtZpqllGK%2FusbEp2RwZWVsfXGzjJqlnWWirsemuoxuZG5uYGW0bq3PrmSrnaaesrh7lA%3D%3D</p></section><nav class=post-nav><a class=prev href=./bailey-bass-net-worth.html><span>←</span><span>Bailey Bass Net Worth | Biography</span></a>
<a class=next href=./hunter-dickinson-net-worth-283142.html><span>Hunter Dickinson Net Worth</span><span>→</span></a></nav></article></main><footer class=footer><p>&copy; 2024 <a href=./></a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p></footer><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/banner.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>